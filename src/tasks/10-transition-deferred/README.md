# Задача 10 — useTransition и useDeferredValue

**Уровень:** senior

## Цель

Отложенные обновления при тяжёлых операциях: `useTransition` для неблокирующего state, `useDeferredValue` для отложенного ввода в поиск/фильтр. Сохранить отзывчивость UI.

## Требования

- Сценарий 1: тяжёлое обновление (например, фильтрация большого списка по вводу). Использовать `useDeferredValue` для значения поиска: инпут обновляется сразу, тяжёлый список рендерится с отложенным значением — UI не «зависает».
- Сценарий 2: переход к новому «экрану» или состоянию, которое долго рендерится. Использовать `useTransition`: кнопка/ссылка остаётся отзывчивой, показывать pending-состояние (опционально), тяжёлый рендер не блокирует ввод.
- Продемонстрировать разницу: без отложенных обновлений ввод лагает; с ними — остаётся плавным.

## Подсказки

- `const [isPending, startTransition] = useTransition()`; обновления внутри `startTransition(() => setState(...))` имеют низкий приоритет.
- `const deferredQuery = useDeferredValue(query)`; использовать `deferredQuery` для тяжёлых вычислений, `query` — для отображения в инпуте.
- Искусственно замедлить фильтрацию (цикл или задержка), чтобы эффект был заметен.

## Критерии приёмки

- При быстром вводе в поле поиска/фильтра инпут не лагает (используется useDeferredValue или аналог).
- Тяжёлое обновление не блокирует UI (useTransition или отложенное значение).
- Результат в итоге соответствует последнему вводу (нет «прыгающего» устаревшего контента).
