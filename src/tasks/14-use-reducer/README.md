# Задача 14 — useReducer и сложная логика состояния

**Уровень:** продвинутый

## Цель

Реализовать виджет с несколькими шагами (stepper/wizard) или похожую многошаговую логику. Использовать `useReducer` для управления переходами между состояниями: чистый reducer, предсказуемые переходы, тестируемая логика.

## Требования

- Несколько шагов/состояний (например: шаг 1 — ввод данных, шаг 2 — подтверждение, шаг 3 — результат).
- `useReducer` вместо набора `useState`: один state-объект и reducer, обрабатывающий actions (NEXT, PREV, RESET, SET_DATA и т.п.).
- Reducer — чистая функция: `(state, action) => newState`; легко тестировать отдельно.
- Навигация между шагами: кнопки «Далее», «Назад», сброс к первому шагу при необходимости.
- Данные, введённые на предыдущих шагах, сохраняются в state и отображаются на следующих.

## Подсказки

- `const [state, dispatch] = useReducer(reducer, initialState)`
- Actions: `{ type: 'NEXT' }`, `{ type: 'PREV' }`, `{ type: 'SET_FIELD', field: 'name', value: '...' }`
- Можно добавить валидацию: переход на следующий шаг только при валидных данных (проверка в reducer или в обработчике перед dispatch).
- Для state machine — можно хранить `step: 'idle' | 'step1' | 'step2' | 'done'` и проверять допустимые переходы.

## Критерии приёмки

- Логика переходов сосредоточена в reducer.
- Reducer можно вынести и unit-тестировать отдельно.
- «Назад» возвращает на предыдущий шаг с сохранёнными данными.
- При сбросе (если есть) state возвращается к начальному.
